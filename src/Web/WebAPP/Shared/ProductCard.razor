@using Contracts.Abstractions.Paging
@using WebAPP.Abstractions.Http
@using WebAPP.HttpClients
@using BlazorStrap
@using Contracts.Services.Catalogs

@inject IECommerceHttpClient HttpClient
@inject IBlazorStrap BlazorStrap

<BSContainer>
    @if (_items.Any() is false)
    {
        <p>
            Nothing to show.
        </p>
    }
    else
    {
        <BSRow MarginTop="Margins.Large">
            @foreach (var item in _items)
            {
                <BSCard Class="w-25 border-0" Alignment="Alignment.Center" CardType="CardType.Card">
                    <BSCard Class="rounded-1" CardType="CardType.Image" src="placeholder:286x180"/>
                    <BSCard CardType="CardType.Body">
                        <BSCard CardType="CardType.Title">@item.Product.Name</BSCard>
                        <BSCard CardType="CardType.Subtitle">@item.Product.Description</BSCard>
                        @* <BSButton Color="BSColor.Warning" OnClick=@(() => EditAsync("New Title", catalog.ItemId))>Edit</BSButton> *@
                        @* <BSButton Color="BSColor.Danger" OnClick="() => DeleteAsync(catalog.ItemId)">Delete</BSButton> *@
                    </BSCard>
                </BSCard>
            }
        </BSRow>
        <BSPagination Align="Align.Center">
            <BSPaginationItem IsDisabled=@(_pageInfo.HasPrevious is false) @onclick="MoveToPreview">Previous</BSPaginationItem>
            @for (var paging = 1; paging <= _pageInfo.Current; paging++)
            {
                var current = paging;
                <BSPaginationItem @onclick=@(() => MoveToPage(current))>@current</BSPaginationItem>
            }
            <BSPaginationItem IsDisabled=@(_pageInfo.HasNext is false) @onclick="MoveToNext">Next</BSPaginationItem>
        </BSPagination>
    }
</BSContainer >

@code {

    private List<Projection.CatalogItem> _items;
    private PageInfo _pageInfo;

    protected override async Task OnInitializedAsync()
        => await LoadAsync();

    private async Task LoadAsync(int limit = 8, int offset = 0)
    {
        try
        {
            var response = await HttpClient.GetAllItemsAsync(limit, offset, CancellationToken.None);

            if (response.Success)
            {
                _items = response.ActionResult?.Items?.ToList() ?? _items;
                _pageInfo = response.ActionResult?.PageInfo ?? new();
            }
            else Failed(response.Message);
        }
        catch (Exception e)
        {
            Failed(e.Message);
        }
    }

    private void Failed(string error = default)
    {
        BlazorStrap.Toaster.Add("Error", error ?? "It was not possible to create a new Catalog", o =>
        {
            o.Color = BSColor.Danger;
            o.CloseAfter = 2000;
            o.Toast = Toast.BottomRight;
        });
    }

    private Task MoveToPage(int current)
        => LoadAsync(offset: current - 1);

    private async Task MoveToNext()
    {
        if (_pageInfo.HasNext)
            await LoadAsync(offset: _pageInfo.Current);
    }

    private async Task MoveToPreview()
    {
        if (_pageInfo.HasPrevious)
            await LoadAsync(offset: _pageInfo.Current - 2);
    }

}